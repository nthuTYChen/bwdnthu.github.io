<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>Bilingual Web Design@DFLL NTHU; Tsung-Ying Chen</title>
		<link rel="stylesheet" href="/css/style.css">
		<script src="/js/jquery-3.2.1.min.js"></script>
		<meta charset="UTF-8">
	</head>
	<body>
		<nav>
			<h2>
				<a href="/bwd/">Intro</a>
				<a href="/bwd/htmlbasics/">HTML Basics</a>
				<a href="/bwd/cssbasics/">CSS Basics</a>
				<a href="/bwd/jsbasics/">JS Basics</a>
				<a href="/bwd/jquery/">jQuery</a>
				<a class="selected" href="/bwd/rwd/">Responsive Web</a>
				<a href="/bwd/cssanimation/">CSS Animation</a>
				<a href="/bwd/engissues/">English Issues</a>
				<a href="/bwd/students/">Students</a>
			</h2>
		</nav>
		<div class="container">
			<article>
				<h1>6. Responsive Web Design</h1>
				<p>Who's still using a computer? And your websites should respond to this question.</p>
				<p><a href="#overview">Overview</a> / <a href="#prepwork">Preparation work</a> / <a href="#rwdmenu">Responsive menus</a> / <a href="#flexbox">CSS flex box</a> / <a href="#touchevent">Touch events</a> / <a href="#forthenextunit">For the next unit...</a></p>
				<section>
					<h2 id="overview">Overview</h2>
					<picture>
						<img src="img/this-is-the-web.png" style="width: 30%;" />
						<sub>Source: <a href="https://bradfrost.com/blog/post/this-is-the-web/" target="_blank">Brad Frost</a></sub>
					</picture>
					<p>The world is changing, and so is Web Design. There are just so many digital devices coming out each year, and they all get a different screen resolution, and a notable difference driven by this revolutionary progress is the contrast between the <em class="extra">portrait view</em> and the <em class="extra">landscape view</em>. In the former, the screen width is longer than the screen height, whereas it is the other way around in the latter. If your websites are designed to be best viewed with the portrait view, then its layout will inevitably a mess in the portrait view. Since this course website is not designed specifically to be viewed in the portrait mode, it won't look decent in your smart phone, albeit not a total disater.</p>
					<p>This is why you need to make your websites <em class="extra">responsive</em> to different screen resolutions, so when somebody interested in you and check your websites with their mobile devices, they don't feel frustrated and instead recognize you as a professional Web designer.</p>
				</section>
				<section>
					<h2 id="prepwork">Preparation work</h2>
					<p>The first step in making your websites responsive is to tell Web browsers that your websites are responsive with the <em class="extra">metadata</em> added to <code>&lt;head&gt;</code> below.</p>
					<code>
						&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
					</code>
					<p>In this <code>meta</code> element, we first include <code>name="viewport"</code> to tell <em class="extra">mobile browsers</em> to refer to a specific initial size of the <em class="extra">viewport</em> (that is, the visible area of Web contents). Why? When a website is not designed to be responsive, the width of an HTML document is almost certainly longer than the width of a mobile device in its portrait view. A mobile Web browser may thus use a <em>virtual viewport</em> to shrink the webpage and render the shrinked version to the <em>actual viewport</em>. Since a virtual viewport is always used by a mobile browser, it is not possible for a webpage to use a different layout based on a different device width. Setting <code>name="viewport"</code> stops a mobile Web browser from using a virtual viewport in all cases and allows the browser to adopt a designed layout for a viewport smaller than a specific size (with recourse to <em>media queries</em>. See below). This is relevant to the setting in <code>content="width=device-width, initial-scale=1.0"</code>. In the value of the <code>content</code> attribute, we define two separate <em class="extra">subvalues</em>. The first subvalue <code>width=device-width</code> means that the actual viewport width used by the Web browser varies by the width of different devices. This is the most crucial part in setting up a responsive website since users' devices have all different screen widths as discussed in the previous section. The second subvalue tells the browser to initially scale the viewport size to the original one (1.0 = 100%), so the layout is always adjusted based on the actual viewport width of the device. This line of metadata would work in most responsive website projects, but if you want to know a bit more about this part, see <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag" target="_blank">this page in MDN Web Docs</a></p>
					<h3>Media query</h3>
					<p>After you set up the metadata for a responsive webpage properly, you can then define different layout in a CSS file with <em class="extra">media queries</em> using <code>@media</code> rules as in the following example:</p>
					<code>
						@media screen and (max-width: 800px) {
						<code>
							/* some CSS styles */
						</code>
						}
					</code>
					<p>The above example defines a block of CSS styles that applies only when the media, which is set to be the device screen, has a width of 800 pixels at maximum. Following this logic, we can have CSS styles that apply by default except in some cases:</p>
					<code>
						/* Default DIV style */<br/>
						div {
						<code>
							background-color: red;<br/>
							width: 30%;
						</code>
						}<br/>
						@media screen and (max-width: 800px) {
						<code>
							/* DIV style applied in a narrower device */<br/>
							div {
							<code>
								width: 100%;
							</code>
							}
						</code>
						}
					</code>
					<p>In this example, the width of a <code>&lt;div&gt;</code> element is by default 30% of the width of its immediate ancestor, but is adjusted into 100% in a device with a screen width of 800 pixels or lower. Since the property <code>background-color</code> is not set to a different value in the block inside the media query, it would remain unchanged and still embellish a <code>&lt;div&gt;</code> element with a red background color.</p>
					<h3>Mobile first</h3>
					<picture>
						<img src="img/mobile-dominate.png" style="width: 40%; max-width: 600px;" />
						<sub>Source: <a href="https://www.flickr.com/photos/gunman47/49929221131" target="_blank">Dickson Phua</a></sub>
					</picture>
					<p>Mobile devices are dominating the world. Period. So when you start a responsive website project, the first thing you need to think is the layout optimized for mobile devices by default, and then adjust this mobile-based layout for some desktop devices. Thus, you should set media query rules specifically for the desktop devices, rather than for mobile devices. As in the following example, we would define CSS styles that apply only to devices with a screen width of 1,200 pixels or higher (using <code>min-width</code>). The number 1,200 is going to be a safe <em>break point</em>, as most mobile devices have a viewport width shorter than 1,200 pixels (see <a href="https://docs.adobe.com/content/help/en/target/using/experiences/vec/mobile-viewports.html" target="_blank">this Adobe page</a>). About twenty five years ago, a desktop computer screen with a 1024 x 768 resolution would be considered a "large" screen, but I guess most of them are dead by now, so we should be fine.</p>
					<code>
						@media screen and (min-width: 1200px) {
						<code>
							/* CSS styles applied in a wider device */<br/>
						</code>
						}
					</code>
					<h3>Mobile Safari sucks</h3>
					<picture>
						<img src="img/safari-background.jpg" style="width: 30%;" />
						<sub>Source: <a href="https://www.telerik.com/blogs/safari-is-not-the-new-ie-but" target="_blank">TJ Van Toll</a></sub>
					</picture>
					<p>As we proceed to develop a mobile-friendly website, we would try different things to make it easier to navigate via a Web browser. Then, at some point of time, you will almost necessarily blame mobile Safari for producing unexpected bugs in your website. Since there is a vast body of iPhone users, you don't really want to exclude this user base that would greatly contribute to the number of page views of your website, which can lead to a higher profit if you work on a commercial project. This means that you always need to look for solutions that are specific to mobile Safari, which is really agitating. But if profit is not your primary concern, maybe you could choose not to give a damn, just like me. I am not the only person whining about how poor mobile Safari is (see <a href="https://www.eventbrite.com/engineering/mobile-safari-why/" target="_blank">this page</a> or <a href="https://www.telerik.com/blogs/safari-is-not-the-new-ie-but" target="_blank">this one</a>, for example), and Apple has been ignoring this issue for years. Let's hope Apple can fix all the issues in the coming years, rather than just focus on how expensive a new iPhone should be.</p>
				</section>
				<section>
					<h2 id="rwdmenu">Responsive menus</h2>
					<p>With media queries, there are two ways to present different navigation panes in different contexts. One is to have only one <code>&lt;nav&gt;</code> in your HTML document, which is <em>transformed</em> by different CSS styles in various browsers. The other is to have two <code>&lt;nav&gt;</code> elements that are organized and styled differently in a CSS file, and simply use media queries to decide when to display which one. The first transforming approach is more complicated on the CSS side, as you need to try hard to make sure the CSS styles applied in different contexts can adjust same navigation pane properly, but it is useful if your menu has a huge number of items so duplicating the entire menu may increase the size of a webpage unnecessarily. The second hide-and-seek approach is easier to implement, but only when your menu has only a few item. I'll do a very simple demonstration below, and it's up to you to choose the one that is most appropriate in your case. You can also create just one mobile-based drop-down menu for all contexts, although it could confuse the users a little bit when they are using their laptop or desktop computer.</p>
					<h3>The transforming approach</h3>
					<p>Let's first create a navigation pane with just two items with a <em class="extra">hamburger menu</em> Unicode symbol:</p>
					<code>
						&lt;nav&gt;
						<code>
							&lt;span&gt;&#9776;&lt;/span&gt;<br/>
							&lt;a href="#"&gt;Item 1&gt;/a&gt;<br/>
							&lt;a href="#"&gt;Item 1&gt;/a&gt;
						</code>
						&lt;/nav&gt;
					</code>
					<p>Now let's give the nagivation pane a decent look in a mobile-browsing context (remember the <em class="extra">mobile first</em> principle?). The main aspects in the following CSS styles are as follows. First, the <code>&lt;nav&gt;</code> element is set to take the full width of the viewport, and it is fixed to the top of the viewport. Second, the height of the menu is set to the 5% of the viewport height, which is also the line height of the element to help align texts vertically. Since this mobile-based menu is created as a drop-down menu, its items are hidden by default, and they will only be presented when the hamburger icon is clicked.</p>
					<code>
						nav {
						<code>
							position: fixed;<br/>
							top: 0;<br/>
							width: 100%;<br/>
							background-color: black;<br/>
							color: white;<br/>
							height: 5vh;<br/>
							line-height: 5vh;<br/>
							opacity: 0.95;
						</code>
						}<br/><br/>
						nav > a {
							<code>
								display: none;<br/>
								color: white;<br/>
								text-align: center;<br/>
								text-decoration: none;
							</code>
						}
					</code>
					<p>The rest of the tricks relies on jQuery - we add a listener to the hamburger menu, and show its <code>&lt;a&gt;</code> siblings when it's clicked.</p>
					<code>
						window.onload = function() {
						<code>
							$('nav > span').on('click', function() {
							<code>
								$(this).siblings().css('display', 'inline');
							</code>
							});
						</code>
						};
					</code>
					<p>The above codes help present <code>&lt;a&gt;</code> elements as they were - namely <em class="extra">inline</em> elements. But we need a drop-down menu, and this can be done by changing <code>inline</code> to <code>block</code> in the above JS codes. Do you know why?</p>
					<code>
						$(this).siblings().css('display', 'block');
					</code>
					<p>Now only do <code>&lt;a&gt;</code> elements appear automatically below the menu bar, these elements also take up the full viewport width. Why? Once an inline element is turned into a block element, it takes width and height settings, which, in the current case, are <em>cascaded</em> from their parent <code>&lt;nav&gt;</code>.</p>
					<p>OK, it seems like we have had a great start. Now, how can we hide the menu items by clicking the hamburger symbol again? Easy. We can get it done with the <code>if...else...</code> statement - if the items are hidden, show them, or hide them if they are present. In this first line inside the event listener below, we first check if the first sibling <code>&lt;a&gt;</code> element has a <code>none</code> value for its <code>display</code> property, and store the <em class="extra">boolean</em> value into the variable <code>hidden</code>. The presentation of all sibling <code>&lt;a&gt;</code> elements is then determined by this variable.</p>
					<code>
						$('nav > span').on('click', function() {
						<code>
							//Check if the first &lt;a&gt; is hidden<br/>
							var hidden = ($('nav > span').siblings().eq(0).css('display') === 'none');<br/>
							if(hidden) {
							<code>
								$(this).siblings().css('display', 'block');
							</code>
							}<br/>
							else {
							<code>
								$(this).siblings().css('display', 'none');
							</code>
							}
						</code>
						});
					</code>
					<p>It's time to transform this drop-down menu to the one with a horizontal layout with media queries. Let's also set the <em>break point</em> to a viewport width of <em>1,200 pixels</em> in the CSS file, and our first change is to hide the hamburger symbol. Once the symbol is hidden, you don't need to be worried about clicking the symbol and trigger unexpected actions by accident. Second, let's set the <code>&lt;a&gt;</code> siblings to be <em>inline-block</em> elements. The reason is that we want the elements to be treated like a normal text flow but at the time made flexible in terms of their height and width. Now adjust the width of your Web browser, and see how the website <em>responds</em> to the change!</p>
					<code>
						@media screen and (min-width: 1200px) {
						<code>
							nav > span {
							<code>
								display: none;
							</code>
							}<br/><br/>
							nav > a {
							<code>
								display: inline-block;<br/>
								height: 5vh;<br/>
								width: 10%;
							</code>
							}
						</code>
						}
					</code>
					<h3>The hide-and-seek approach</h3>
					<p>As mentioned above, when you adopt a hide-and-seek approach, you need to have two <code>&lt;nav&gt;</code> elements in your HTML document, which are styled differently and displayed in different contexts. Let's start with the HTML part first:</p>
					<code>
						&lt;nav id="desktopMenu"&gt;
						<code>
							&lt;a href="#"&gt;Item 1&gt;/a&gt;<br/>
							&lt;a href="#"&gt;Item 1&gt;/a&gt;
						</code>
						&lt;/nav&gt;<br/>
						&lt;nav id="mobileMenu"&gt;
						<code>
							&lt;span&gt;&#9776;&lt;/span&gt;<br/>
							&lt;a href="#"&gt;Item 1&gt;/a&gt;<br/>
							&lt;a href="#"&gt;Item 1&gt;/a&gt;
						</code>
						&lt;/nav&gt;
					</code>
					<p>With two <code>&lt;nav&gt;</code> elements that are specified with a different <code>id</code> attribute, their appearance can be made very distinct, and one could be hidden when the other is present:</p>
					<code>
						/* All &lt;a&gt; in &lt;nav&gt; share the same text styles and layout */
						nav > a {
						<code>
							display: block;<br/>
							background-color: grey;<br/>
							color: black;<br/>
							text-align: center;
						</code>
						}<br/>
						/* Mobile first - mobile menu is visible by default */<br/>
						nav#mobileMenu {
						<code>
							display: block;
							background-color: black;<br/>
							color: white;<br/>
							height: 5vh;<br/>
							width: 100%;<br/>
							line-height: 5vh;
						</code>
						}<br/>
						/* Desktop menu is hidden by default */<br/>
						nav#desktopMenu {
						<code>
							display: none;	
						</code>
						}<br/>
						/* Applied only when viewport width < 1200 px */<br/>
						@media screen and (min-width: 1200px) {
						<code>
							nav#mobileMenu {
							<code>
								display: none;
							</code>
							}<br/>
							/* Define the desktopMenu style here */
							nav#desktopMenu {
							<code>
								display:block;<br/>
								position: fixed;<br/>
								top: 5vh;<br/>
								left: 10vw;<br/>
								height: 5vh;<br/>
								width: 10vh;<br/>
								line-height: 5vh;
							</code>
							}
						</code>
						}
					</code>
					<p>Without the need to transform one <code>&lt;nav&gt;</code> layout into another, we can easily move a navigation pane away from the top/left edge in the desktop landscape view and define its menu items separately. These two logics may be applied to other elements in a webpage, but of course you don't want to duplicate everything - it's just a <em class="extra">poor practice</em> in Web design.</p>
				</section>
				<section>
					<h2 id="flexbox">CSS flex box</h2>
					<p>As noted earlier, you can't just keep being lazy and duplicate everything, let along the elements that includes the main contents of a website.</p>
					<code>
						display: flex;<br/>
						flex-direction: row;<br/>
						justify-content: center;<br/>
					</code>
				</section>
				<section>
					<h2 id="forthenextunit">For the next unit...</h2>
					<p><button onclick="rwd()">>> CSS Animation</button></p>
					<script>
						function rwd() {
							window.location.href = '/bwd/cssanimation/';
						}
					</script>
				</section>
				<sub>All Copyright Reserved; Tsung-Ying Chen 2020</sub>
			</article>
		</div>
	</body>
</html>